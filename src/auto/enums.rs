// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use std::fmt;
use webkit2_sys;

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum AuthenticationScheme {
    Default,
    HttpBasic,
    HttpDigest,
    HtmlForm,
    Ntlm,
    Negotiate,
    ClientCertificateRequested,
    ServerTrustEvaluationRequested,
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl fmt::Display for AuthenticationScheme {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AuthenticationScheme::{}", match *self {
            AuthenticationScheme::Default => "Default",
            AuthenticationScheme::HttpBasic => "HttpBasic",
            AuthenticationScheme::HttpDigest => "HttpDigest",
            AuthenticationScheme::HtmlForm => "HtmlForm",
            AuthenticationScheme::Ntlm => "Ntlm",
            AuthenticationScheme::Negotiate => "Negotiate",
            AuthenticationScheme::ClientCertificateRequested => "ClientCertificateRequested",
            AuthenticationScheme::ServerTrustEvaluationRequested => "ServerTrustEvaluationRequested",
            AuthenticationScheme::Unknown => "Unknown",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for AuthenticationScheme {
    type GlibType = webkit2_sys::WebKitAuthenticationScheme;

    fn to_glib(&self) -> webkit2_sys::WebKitAuthenticationScheme {
        match *self {
            AuthenticationScheme::Default => webkit2_sys::WEBKIT_AUTHENTICATION_SCHEME_DEFAULT,
            AuthenticationScheme::HttpBasic => webkit2_sys::WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC,
            AuthenticationScheme::HttpDigest => webkit2_sys::WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST,
            AuthenticationScheme::HtmlForm => webkit2_sys::WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM,
            AuthenticationScheme::Ntlm => webkit2_sys::WEBKIT_AUTHENTICATION_SCHEME_NTLM,
            AuthenticationScheme::Negotiate => webkit2_sys::WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE,
            AuthenticationScheme::ClientCertificateRequested => webkit2_sys::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED,
            AuthenticationScheme::ServerTrustEvaluationRequested => webkit2_sys::WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED,
            AuthenticationScheme::Unknown => webkit2_sys::WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN,
            AuthenticationScheme::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitAuthenticationScheme> for AuthenticationScheme {
    fn from_glib(value: webkit2_sys::WebKitAuthenticationScheme) -> Self {
        skip_assert_initialized!();
        match value {
            1 => AuthenticationScheme::Default,
            2 => AuthenticationScheme::HttpBasic,
            3 => AuthenticationScheme::HttpDigest,
            4 => AuthenticationScheme::HtmlForm,
            5 => AuthenticationScheme::Ntlm,
            6 => AuthenticationScheme::Negotiate,
            7 => AuthenticationScheme::ClientCertificateRequested,
            8 => AuthenticationScheme::ServerTrustEvaluationRequested,
            100 => AuthenticationScheme::Unknown,
            value => AuthenticationScheme::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl StaticType for AuthenticationScheme {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_authentication_scheme_get_type()) }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl<'a> FromValueOptional<'a> for AuthenticationScheme {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl<'a> FromValue<'a> for AuthenticationScheme {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl SetValue for AuthenticationScheme {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum AutomationBrowsingContextPresentation {
    Window,
    Tab,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl fmt::Display for AutomationBrowsingContextPresentation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AutomationBrowsingContextPresentation::{}", match *self {
            AutomationBrowsingContextPresentation::Window => "Window",
            AutomationBrowsingContextPresentation::Tab => "Tab",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for AutomationBrowsingContextPresentation {
    type GlibType = webkit2_sys::WebKitAutomationBrowsingContextPresentation;

    fn to_glib(&self) -> webkit2_sys::WebKitAutomationBrowsingContextPresentation {
        match *self {
            AutomationBrowsingContextPresentation::Window => webkit2_sys::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_WINDOW,
            AutomationBrowsingContextPresentation::Tab => webkit2_sys::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_TAB,
            AutomationBrowsingContextPresentation::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitAutomationBrowsingContextPresentation> for AutomationBrowsingContextPresentation {
    fn from_glib(value: webkit2_sys::WebKitAutomationBrowsingContextPresentation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AutomationBrowsingContextPresentation::Window,
            1 => AutomationBrowsingContextPresentation::Tab,
            value => AutomationBrowsingContextPresentation::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl StaticType for AutomationBrowsingContextPresentation {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_automation_browsing_context_presentation_get_type()) }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl<'a> FromValueOptional<'a> for AutomationBrowsingContextPresentation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl<'a> FromValue<'a> for AutomationBrowsingContextPresentation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl SetValue for AutomationBrowsingContextPresentation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum CacheModel {
    DocumentViewer,
    WebBrowser,
    DocumentBrowser,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CacheModel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CacheModel::{}", match *self {
            CacheModel::DocumentViewer => "DocumentViewer",
            CacheModel::WebBrowser => "WebBrowser",
            CacheModel::DocumentBrowser => "DocumentBrowser",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for CacheModel {
    type GlibType = webkit2_sys::WebKitCacheModel;

    fn to_glib(&self) -> webkit2_sys::WebKitCacheModel {
        match *self {
            CacheModel::DocumentViewer => webkit2_sys::WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER,
            CacheModel::WebBrowser => webkit2_sys::WEBKIT_CACHE_MODEL_WEB_BROWSER,
            CacheModel::DocumentBrowser => webkit2_sys::WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER,
            CacheModel::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitCacheModel> for CacheModel {
    fn from_glib(value: webkit2_sys::WebKitCacheModel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CacheModel::DocumentViewer,
            1 => CacheModel::WebBrowser,
            2 => CacheModel::DocumentBrowser,
            value => CacheModel::__Unknown(value),
        }
    }
}

impl StaticType for CacheModel {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_cache_model_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CacheModel {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CacheModel {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CacheModel {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum ContextMenuAction {
    NoAction,
    OpenLink,
    OpenLinkInNewWindow,
    DownloadLinkToDisk,
    CopyLinkToClipboard,
    OpenImageInNewWindow,
    DownloadImageToDisk,
    CopyImageToClipboard,
    CopyImageUrlToClipboard,
    OpenFrameInNewWindow,
    GoBack,
    GoForward,
    Stop,
    Reload,
    Copy,
    Cut,
    Paste,
    Delete,
    SelectAll,
    InputMethods,
    Unicode,
    SpellingGuess,
    NoGuessesFound,
    IgnoreSpelling,
    LearnSpelling,
    IgnoreGrammar,
    FontMenu,
    Bold,
    Italic,
    Underline,
    Outline,
    InspectElement,
    OpenVideoInNewWindow,
    OpenAudioInNewWindow,
    CopyVideoLinkToClipboard,
    CopyAudioLinkToClipboard,
    ToggleMediaControls,
    ToggleMediaLoop,
    EnterVideoFullscreen,
    MediaPlay,
    MediaPause,
    MediaMute,
    DownloadVideoToDisk,
    DownloadAudioToDisk,
    InsertEmoji,
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ContextMenuAction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ContextMenuAction::{}", match *self {
            ContextMenuAction::NoAction => "NoAction",
            ContextMenuAction::OpenLink => "OpenLink",
            ContextMenuAction::OpenLinkInNewWindow => "OpenLinkInNewWindow",
            ContextMenuAction::DownloadLinkToDisk => "DownloadLinkToDisk",
            ContextMenuAction::CopyLinkToClipboard => "CopyLinkToClipboard",
            ContextMenuAction::OpenImageInNewWindow => "OpenImageInNewWindow",
            ContextMenuAction::DownloadImageToDisk => "DownloadImageToDisk",
            ContextMenuAction::CopyImageToClipboard => "CopyImageToClipboard",
            ContextMenuAction::CopyImageUrlToClipboard => "CopyImageUrlToClipboard",
            ContextMenuAction::OpenFrameInNewWindow => "OpenFrameInNewWindow",
            ContextMenuAction::GoBack => "GoBack",
            ContextMenuAction::GoForward => "GoForward",
            ContextMenuAction::Stop => "Stop",
            ContextMenuAction::Reload => "Reload",
            ContextMenuAction::Copy => "Copy",
            ContextMenuAction::Cut => "Cut",
            ContextMenuAction::Paste => "Paste",
            ContextMenuAction::Delete => "Delete",
            ContextMenuAction::SelectAll => "SelectAll",
            ContextMenuAction::InputMethods => "InputMethods",
            ContextMenuAction::Unicode => "Unicode",
            ContextMenuAction::SpellingGuess => "SpellingGuess",
            ContextMenuAction::NoGuessesFound => "NoGuessesFound",
            ContextMenuAction::IgnoreSpelling => "IgnoreSpelling",
            ContextMenuAction::LearnSpelling => "LearnSpelling",
            ContextMenuAction::IgnoreGrammar => "IgnoreGrammar",
            ContextMenuAction::FontMenu => "FontMenu",
            ContextMenuAction::Bold => "Bold",
            ContextMenuAction::Italic => "Italic",
            ContextMenuAction::Underline => "Underline",
            ContextMenuAction::Outline => "Outline",
            ContextMenuAction::InspectElement => "InspectElement",
            ContextMenuAction::OpenVideoInNewWindow => "OpenVideoInNewWindow",
            ContextMenuAction::OpenAudioInNewWindow => "OpenAudioInNewWindow",
            ContextMenuAction::CopyVideoLinkToClipboard => "CopyVideoLinkToClipboard",
            ContextMenuAction::CopyAudioLinkToClipboard => "CopyAudioLinkToClipboard",
            ContextMenuAction::ToggleMediaControls => "ToggleMediaControls",
            ContextMenuAction::ToggleMediaLoop => "ToggleMediaLoop",
            ContextMenuAction::EnterVideoFullscreen => "EnterVideoFullscreen",
            ContextMenuAction::MediaPlay => "MediaPlay",
            ContextMenuAction::MediaPause => "MediaPause",
            ContextMenuAction::MediaMute => "MediaMute",
            ContextMenuAction::DownloadVideoToDisk => "DownloadVideoToDisk",
            ContextMenuAction::DownloadAudioToDisk => "DownloadAudioToDisk",
            ContextMenuAction::InsertEmoji => "InsertEmoji",
            ContextMenuAction::Custom => "Custom",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for ContextMenuAction {
    type GlibType = webkit2_sys::WebKitContextMenuAction;

    fn to_glib(&self) -> webkit2_sys::WebKitContextMenuAction {
        match *self {
            ContextMenuAction::NoAction => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION,
            ContextMenuAction::OpenLink => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK,
            ContextMenuAction::OpenLinkInNewWindow => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW,
            ContextMenuAction::DownloadLinkToDisk => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK,
            ContextMenuAction::CopyLinkToClipboard => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD,
            ContextMenuAction::OpenImageInNewWindow => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW,
            ContextMenuAction::DownloadImageToDisk => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK,
            ContextMenuAction::CopyImageToClipboard => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD,
            ContextMenuAction::CopyImageUrlToClipboard => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_URL_TO_CLIPBOARD,
            ContextMenuAction::OpenFrameInNewWindow => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW,
            ContextMenuAction::GoBack => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_GO_BACK,
            ContextMenuAction::GoForward => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD,
            ContextMenuAction::Stop => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_STOP,
            ContextMenuAction::Reload => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_RELOAD,
            ContextMenuAction::Copy => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_COPY,
            ContextMenuAction::Cut => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_CUT,
            ContextMenuAction::Paste => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_PASTE,
            ContextMenuAction::Delete => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_DELETE,
            ContextMenuAction::SelectAll => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_SELECT_ALL,
            ContextMenuAction::InputMethods => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_INPUT_METHODS,
            ContextMenuAction::Unicode => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_UNICODE,
            ContextMenuAction::SpellingGuess => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS,
            ContextMenuAction::NoGuessesFound => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND,
            ContextMenuAction::IgnoreSpelling => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING,
            ContextMenuAction::LearnSpelling => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING,
            ContextMenuAction::IgnoreGrammar => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR,
            ContextMenuAction::FontMenu => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU,
            ContextMenuAction::Bold => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_BOLD,
            ContextMenuAction::Italic => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_ITALIC,
            ContextMenuAction::Underline => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE,
            ContextMenuAction::Outline => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_OUTLINE,
            ContextMenuAction::InspectElement => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT,
            ContextMenuAction::OpenVideoInNewWindow => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW,
            ContextMenuAction::OpenAudioInNewWindow => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW,
            ContextMenuAction::CopyVideoLinkToClipboard => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD,
            ContextMenuAction::CopyAudioLinkToClipboard => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD,
            ContextMenuAction::ToggleMediaControls => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS,
            ContextMenuAction::ToggleMediaLoop => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP,
            ContextMenuAction::EnterVideoFullscreen => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN,
            ContextMenuAction::MediaPlay => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY,
            ContextMenuAction::MediaPause => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE,
            ContextMenuAction::MediaMute => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE,
            ContextMenuAction::DownloadVideoToDisk => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK,
            ContextMenuAction::DownloadAudioToDisk => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK,
            ContextMenuAction::InsertEmoji => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_INSERT_EMOJI,
            ContextMenuAction::Custom => webkit2_sys::WEBKIT_CONTEXT_MENU_ACTION_CUSTOM,
            ContextMenuAction::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitContextMenuAction> for ContextMenuAction {
    fn from_glib(value: webkit2_sys::WebKitContextMenuAction) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ContextMenuAction::NoAction,
            1 => ContextMenuAction::OpenLink,
            2 => ContextMenuAction::OpenLinkInNewWindow,
            3 => ContextMenuAction::DownloadLinkToDisk,
            4 => ContextMenuAction::CopyLinkToClipboard,
            5 => ContextMenuAction::OpenImageInNewWindow,
            6 => ContextMenuAction::DownloadImageToDisk,
            7 => ContextMenuAction::CopyImageToClipboard,
            8 => ContextMenuAction::CopyImageUrlToClipboard,
            9 => ContextMenuAction::OpenFrameInNewWindow,
            10 => ContextMenuAction::GoBack,
            11 => ContextMenuAction::GoForward,
            12 => ContextMenuAction::Stop,
            13 => ContextMenuAction::Reload,
            14 => ContextMenuAction::Copy,
            15 => ContextMenuAction::Cut,
            16 => ContextMenuAction::Paste,
            17 => ContextMenuAction::Delete,
            18 => ContextMenuAction::SelectAll,
            19 => ContextMenuAction::InputMethods,
            20 => ContextMenuAction::Unicode,
            21 => ContextMenuAction::SpellingGuess,
            22 => ContextMenuAction::NoGuessesFound,
            23 => ContextMenuAction::IgnoreSpelling,
            24 => ContextMenuAction::LearnSpelling,
            25 => ContextMenuAction::IgnoreGrammar,
            26 => ContextMenuAction::FontMenu,
            27 => ContextMenuAction::Bold,
            28 => ContextMenuAction::Italic,
            29 => ContextMenuAction::Underline,
            30 => ContextMenuAction::Outline,
            31 => ContextMenuAction::InspectElement,
            32 => ContextMenuAction::OpenVideoInNewWindow,
            33 => ContextMenuAction::OpenAudioInNewWindow,
            34 => ContextMenuAction::CopyVideoLinkToClipboard,
            35 => ContextMenuAction::CopyAudioLinkToClipboard,
            36 => ContextMenuAction::ToggleMediaControls,
            37 => ContextMenuAction::ToggleMediaLoop,
            38 => ContextMenuAction::EnterVideoFullscreen,
            39 => ContextMenuAction::MediaPlay,
            40 => ContextMenuAction::MediaPause,
            41 => ContextMenuAction::MediaMute,
            42 => ContextMenuAction::DownloadVideoToDisk,
            43 => ContextMenuAction::DownloadAudioToDisk,
            44 => ContextMenuAction::InsertEmoji,
            10000 => ContextMenuAction::Custom,
            value => ContextMenuAction::__Unknown(value),
        }
    }
}

impl StaticType for ContextMenuAction {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_context_menu_action_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ContextMenuAction {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ContextMenuAction {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ContextMenuAction {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum CookieAcceptPolicy {
    Always,
    Never,
    NoThirdParty,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CookieAcceptPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CookieAcceptPolicy::{}", match *self {
            CookieAcceptPolicy::Always => "Always",
            CookieAcceptPolicy::Never => "Never",
            CookieAcceptPolicy::NoThirdParty => "NoThirdParty",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for CookieAcceptPolicy {
    type GlibType = webkit2_sys::WebKitCookieAcceptPolicy;

    fn to_glib(&self) -> webkit2_sys::WebKitCookieAcceptPolicy {
        match *self {
            CookieAcceptPolicy::Always => webkit2_sys::WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS,
            CookieAcceptPolicy::Never => webkit2_sys::WEBKIT_COOKIE_POLICY_ACCEPT_NEVER,
            CookieAcceptPolicy::NoThirdParty => webkit2_sys::WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY,
            CookieAcceptPolicy::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitCookieAcceptPolicy> for CookieAcceptPolicy {
    fn from_glib(value: webkit2_sys::WebKitCookieAcceptPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CookieAcceptPolicy::Always,
            1 => CookieAcceptPolicy::Never,
            2 => CookieAcceptPolicy::NoThirdParty,
            value => CookieAcceptPolicy::__Unknown(value),
        }
    }
}

impl StaticType for CookieAcceptPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_cookie_accept_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CookieAcceptPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CookieAcceptPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CookieAcceptPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum CookiePersistentStorage {
    Text,
    Sqlite,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CookiePersistentStorage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CookiePersistentStorage::{}", match *self {
            CookiePersistentStorage::Text => "Text",
            CookiePersistentStorage::Sqlite => "Sqlite",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for CookiePersistentStorage {
    type GlibType = webkit2_sys::WebKitCookiePersistentStorage;

    fn to_glib(&self) -> webkit2_sys::WebKitCookiePersistentStorage {
        match *self {
            CookiePersistentStorage::Text => webkit2_sys::WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT,
            CookiePersistentStorage::Sqlite => webkit2_sys::WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE,
            CookiePersistentStorage::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitCookiePersistentStorage> for CookiePersistentStorage {
    fn from_glib(value: webkit2_sys::WebKitCookiePersistentStorage) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CookiePersistentStorage::Text,
            1 => CookiePersistentStorage::Sqlite,
            value => CookiePersistentStorage::__Unknown(value),
        }
    }
}

impl StaticType for CookiePersistentStorage {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_cookie_persistent_storage_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CookiePersistentStorage {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CookiePersistentStorage {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CookiePersistentStorage {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum CredentialPersistence {
    None,
    ForSession,
    Permanent,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl fmt::Display for CredentialPersistence {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CredentialPersistence::{}", match *self {
            CredentialPersistence::None => "None",
            CredentialPersistence::ForSession => "ForSession",
            CredentialPersistence::Permanent => "Permanent",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for CredentialPersistence {
    type GlibType = webkit2_sys::WebKitCredentialPersistence;

    fn to_glib(&self) -> webkit2_sys::WebKitCredentialPersistence {
        match *self {
            CredentialPersistence::None => webkit2_sys::WEBKIT_CREDENTIAL_PERSISTENCE_NONE,
            CredentialPersistence::ForSession => webkit2_sys::WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION,
            CredentialPersistence::Permanent => webkit2_sys::WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT,
            CredentialPersistence::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitCredentialPersistence> for CredentialPersistence {
    fn from_glib(value: webkit2_sys::WebKitCredentialPersistence) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CredentialPersistence::None,
            1 => CredentialPersistence::ForSession,
            2 => CredentialPersistence::Permanent,
            value => CredentialPersistence::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl StaticType for CredentialPersistence {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_credential_persistence_get_type()) }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl<'a> FromValueOptional<'a> for CredentialPersistence {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl<'a> FromValue<'a> for CredentialPersistence {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl SetValue for CredentialPersistence {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum DownloadError {
    Network,
    CancelledByUser,
    Destination,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DownloadError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "DownloadError::{}", match *self {
            DownloadError::Network => "Network",
            DownloadError::CancelledByUser => "CancelledByUser",
            DownloadError::Destination => "Destination",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for DownloadError {
    type GlibType = webkit2_sys::WebKitDownloadError;

    fn to_glib(&self) -> webkit2_sys::WebKitDownloadError {
        match *self {
            DownloadError::Network => webkit2_sys::WEBKIT_DOWNLOAD_ERROR_NETWORK,
            DownloadError::CancelledByUser => webkit2_sys::WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER,
            DownloadError::Destination => webkit2_sys::WEBKIT_DOWNLOAD_ERROR_DESTINATION,
            DownloadError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitDownloadError> for DownloadError {
    fn from_glib(value: webkit2_sys::WebKitDownloadError) -> Self {
        skip_assert_initialized!();
        match value {
            499 => DownloadError::Network,
            400 => DownloadError::CancelledByUser,
            401 => DownloadError::Destination,
            value => DownloadError::__Unknown(value),
        }
    }
}

impl ErrorDomain for DownloadError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_download_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            499 => Some(DownloadError::Network),
            400 => Some(DownloadError::CancelledByUser),
            401 => Some(DownloadError::Destination),
            value => Some(DownloadError::__Unknown(value)),
        }
    }
}

impl StaticType for DownloadError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_download_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DownloadError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DownloadError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DownloadError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum FaviconDatabaseError {
    NotInitialized,
    FaviconNotFound,
    FaviconUnknown,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FaviconDatabaseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "FaviconDatabaseError::{}", match *self {
            FaviconDatabaseError::NotInitialized => "NotInitialized",
            FaviconDatabaseError::FaviconNotFound => "FaviconNotFound",
            FaviconDatabaseError::FaviconUnknown => "FaviconUnknown",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for FaviconDatabaseError {
    type GlibType = webkit2_sys::WebKitFaviconDatabaseError;

    fn to_glib(&self) -> webkit2_sys::WebKitFaviconDatabaseError {
        match *self {
            FaviconDatabaseError::NotInitialized => webkit2_sys::WEBKIT_FAVICON_DATABASE_ERROR_NOT_INITIALIZED,
            FaviconDatabaseError::FaviconNotFound => webkit2_sys::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_NOT_FOUND,
            FaviconDatabaseError::FaviconUnknown => webkit2_sys::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_UNKNOWN,
            FaviconDatabaseError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitFaviconDatabaseError> for FaviconDatabaseError {
    fn from_glib(value: webkit2_sys::WebKitFaviconDatabaseError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FaviconDatabaseError::NotInitialized,
            1 => FaviconDatabaseError::FaviconNotFound,
            2 => FaviconDatabaseError::FaviconUnknown,
            value => FaviconDatabaseError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FaviconDatabaseError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_favicon_database_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(FaviconDatabaseError::NotInitialized),
            1 => Some(FaviconDatabaseError::FaviconNotFound),
            2 => Some(FaviconDatabaseError::FaviconUnknown),
            value => Some(FaviconDatabaseError::__Unknown(value)),
        }
    }
}

impl StaticType for FaviconDatabaseError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_favicon_database_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FaviconDatabaseError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FaviconDatabaseError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FaviconDatabaseError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum HardwareAccelerationPolicy {
    OnDemand,
    Always,
    Never,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl fmt::Display for HardwareAccelerationPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "HardwareAccelerationPolicy::{}", match *self {
            HardwareAccelerationPolicy::OnDemand => "OnDemand",
            HardwareAccelerationPolicy::Always => "Always",
            HardwareAccelerationPolicy::Never => "Never",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for HardwareAccelerationPolicy {
    type GlibType = webkit2_sys::WebKitHardwareAccelerationPolicy;

    fn to_glib(&self) -> webkit2_sys::WebKitHardwareAccelerationPolicy {
        match *self {
            HardwareAccelerationPolicy::OnDemand => webkit2_sys::WEBKIT_HARDWARE_ACCELERATION_POLICY_ON_DEMAND,
            HardwareAccelerationPolicy::Always => webkit2_sys::WEBKIT_HARDWARE_ACCELERATION_POLICY_ALWAYS,
            HardwareAccelerationPolicy::Never => webkit2_sys::WEBKIT_HARDWARE_ACCELERATION_POLICY_NEVER,
            HardwareAccelerationPolicy::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitHardwareAccelerationPolicy> for HardwareAccelerationPolicy {
    fn from_glib(value: webkit2_sys::WebKitHardwareAccelerationPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => HardwareAccelerationPolicy::OnDemand,
            1 => HardwareAccelerationPolicy::Always,
            2 => HardwareAccelerationPolicy::Never,
            value => HardwareAccelerationPolicy::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl StaticType for HardwareAccelerationPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_hardware_acceleration_policy_get_type()) }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl<'a> FromValueOptional<'a> for HardwareAccelerationPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl<'a> FromValue<'a> for HardwareAccelerationPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl SetValue for HardwareAccelerationPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum InputPurpose {
    FreeForm,
    Digits,
    Number,
    Phone,
    Url,
    Email,
    Password,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl fmt::Display for InputPurpose {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "InputPurpose::{}", match *self {
            InputPurpose::FreeForm => "FreeForm",
            InputPurpose::Digits => "Digits",
            InputPurpose::Number => "Number",
            InputPurpose::Phone => "Phone",
            InputPurpose::Url => "Url",
            InputPurpose::Email => "Email",
            InputPurpose::Password => "Password",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for InputPurpose {
    type GlibType = webkit2_sys::WebKitInputPurpose;

    fn to_glib(&self) -> webkit2_sys::WebKitInputPurpose {
        match *self {
            InputPurpose::FreeForm => webkit2_sys::WEBKIT_INPUT_PURPOSE_FREE_FORM,
            InputPurpose::Digits => webkit2_sys::WEBKIT_INPUT_PURPOSE_DIGITS,
            InputPurpose::Number => webkit2_sys::WEBKIT_INPUT_PURPOSE_NUMBER,
            InputPurpose::Phone => webkit2_sys::WEBKIT_INPUT_PURPOSE_PHONE,
            InputPurpose::Url => webkit2_sys::WEBKIT_INPUT_PURPOSE_URL,
            InputPurpose::Email => webkit2_sys::WEBKIT_INPUT_PURPOSE_EMAIL,
            InputPurpose::Password => webkit2_sys::WEBKIT_INPUT_PURPOSE_PASSWORD,
            InputPurpose::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitInputPurpose> for InputPurpose {
    fn from_glib(value: webkit2_sys::WebKitInputPurpose) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InputPurpose::FreeForm,
            1 => InputPurpose::Digits,
            2 => InputPurpose::Number,
            3 => InputPurpose::Phone,
            4 => InputPurpose::Url,
            5 => InputPurpose::Email,
            6 => InputPurpose::Password,
            value => InputPurpose::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl StaticType for InputPurpose {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_input_purpose_get_type()) }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl<'a> FromValueOptional<'a> for InputPurpose {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl<'a> FromValue<'a> for InputPurpose {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl SetValue for InputPurpose {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum InsecureContentEvent {
    Run,
    Displayed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InsecureContentEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "InsecureContentEvent::{}", match *self {
            InsecureContentEvent::Run => "Run",
            InsecureContentEvent::Displayed => "Displayed",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for InsecureContentEvent {
    type GlibType = webkit2_sys::WebKitInsecureContentEvent;

    fn to_glib(&self) -> webkit2_sys::WebKitInsecureContentEvent {
        match *self {
            InsecureContentEvent::Run => webkit2_sys::WEBKIT_INSECURE_CONTENT_RUN,
            InsecureContentEvent::Displayed => webkit2_sys::WEBKIT_INSECURE_CONTENT_DISPLAYED,
            InsecureContentEvent::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitInsecureContentEvent> for InsecureContentEvent {
    fn from_glib(value: webkit2_sys::WebKitInsecureContentEvent) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InsecureContentEvent::Run,
            1 => InsecureContentEvent::Displayed,
            value => InsecureContentEvent::__Unknown(value),
        }
    }
}

impl StaticType for InsecureContentEvent {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_insecure_content_event_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InsecureContentEvent {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InsecureContentEvent {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InsecureContentEvent {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum JavascriptError {
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for JavascriptError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "JavascriptError::{}", match *self {
            JavascriptError::Failed => "Failed",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for JavascriptError {
    type GlibType = webkit2_sys::WebKitJavascriptError;

    fn to_glib(&self) -> webkit2_sys::WebKitJavascriptError {
        match *self {
            JavascriptError::Failed => webkit2_sys::WEBKIT_JAVASCRIPT_ERROR_SCRIPT_FAILED,
            JavascriptError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitJavascriptError> for JavascriptError {
    fn from_glib(value: webkit2_sys::WebKitJavascriptError) -> Self {
        skip_assert_initialized!();
        match value {
            699 => JavascriptError::Failed,
            value => JavascriptError::__Unknown(value),
        }
    }
}

impl ErrorDomain for JavascriptError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_javascript_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            699 => Some(JavascriptError::Failed),
            _ => Some(JavascriptError::Failed),
        }
    }
}

impl StaticType for JavascriptError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_javascript_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for JavascriptError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for JavascriptError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for JavascriptError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum LoadEvent {
    Started,
    Redirected,
    Committed,
    Finished,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LoadEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "LoadEvent::{}", match *self {
            LoadEvent::Started => "Started",
            LoadEvent::Redirected => "Redirected",
            LoadEvent::Committed => "Committed",
            LoadEvent::Finished => "Finished",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for LoadEvent {
    type GlibType = webkit2_sys::WebKitLoadEvent;

    fn to_glib(&self) -> webkit2_sys::WebKitLoadEvent {
        match *self {
            LoadEvent::Started => webkit2_sys::WEBKIT_LOAD_STARTED,
            LoadEvent::Redirected => webkit2_sys::WEBKIT_LOAD_REDIRECTED,
            LoadEvent::Committed => webkit2_sys::WEBKIT_LOAD_COMMITTED,
            LoadEvent::Finished => webkit2_sys::WEBKIT_LOAD_FINISHED,
            LoadEvent::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitLoadEvent> for LoadEvent {
    fn from_glib(value: webkit2_sys::WebKitLoadEvent) -> Self {
        skip_assert_initialized!();
        match value {
            0 => LoadEvent::Started,
            1 => LoadEvent::Redirected,
            2 => LoadEvent::Committed,
            3 => LoadEvent::Finished,
            value => LoadEvent::__Unknown(value),
        }
    }
}

impl StaticType for LoadEvent {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_load_event_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for LoadEvent {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for LoadEvent {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for LoadEvent {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum NavigationType {
    LinkClicked,
    FormSubmitted,
    BackForward,
    Reload,
    FormResubmitted,
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NavigationType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "NavigationType::{}", match *self {
            NavigationType::LinkClicked => "LinkClicked",
            NavigationType::FormSubmitted => "FormSubmitted",
            NavigationType::BackForward => "BackForward",
            NavigationType::Reload => "Reload",
            NavigationType::FormResubmitted => "FormResubmitted",
            NavigationType::Other => "Other",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for NavigationType {
    type GlibType = webkit2_sys::WebKitNavigationType;

    fn to_glib(&self) -> webkit2_sys::WebKitNavigationType {
        match *self {
            NavigationType::LinkClicked => webkit2_sys::WEBKIT_NAVIGATION_TYPE_LINK_CLICKED,
            NavigationType::FormSubmitted => webkit2_sys::WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED,
            NavigationType::BackForward => webkit2_sys::WEBKIT_NAVIGATION_TYPE_BACK_FORWARD,
            NavigationType::Reload => webkit2_sys::WEBKIT_NAVIGATION_TYPE_RELOAD,
            NavigationType::FormResubmitted => webkit2_sys::WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED,
            NavigationType::Other => webkit2_sys::WEBKIT_NAVIGATION_TYPE_OTHER,
            NavigationType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitNavigationType> for NavigationType {
    fn from_glib(value: webkit2_sys::WebKitNavigationType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NavigationType::LinkClicked,
            1 => NavigationType::FormSubmitted,
            2 => NavigationType::BackForward,
            3 => NavigationType::Reload,
            4 => NavigationType::FormResubmitted,
            5 => NavigationType::Other,
            value => NavigationType::__Unknown(value),
        }
    }
}

impl StaticType for NavigationType {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_navigation_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NavigationType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NavigationType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NavigationType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum NetworkError {
    Failed,
    Transport,
    UnknownProtocol,
    Cancelled,
    FileDoesNotExist,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NetworkError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "NetworkError::{}", match *self {
            NetworkError::Failed => "Failed",
            NetworkError::Transport => "Transport",
            NetworkError::UnknownProtocol => "UnknownProtocol",
            NetworkError::Cancelled => "Cancelled",
            NetworkError::FileDoesNotExist => "FileDoesNotExist",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for NetworkError {
    type GlibType = webkit2_sys::WebKitNetworkError;

    fn to_glib(&self) -> webkit2_sys::WebKitNetworkError {
        match *self {
            NetworkError::Failed => webkit2_sys::WEBKIT_NETWORK_ERROR_FAILED,
            NetworkError::Transport => webkit2_sys::WEBKIT_NETWORK_ERROR_TRANSPORT,
            NetworkError::UnknownProtocol => webkit2_sys::WEBKIT_NETWORK_ERROR_UNKNOWN_PROTOCOL,
            NetworkError::Cancelled => webkit2_sys::WEBKIT_NETWORK_ERROR_CANCELLED,
            NetworkError::FileDoesNotExist => webkit2_sys::WEBKIT_NETWORK_ERROR_FILE_DOES_NOT_EXIST,
            NetworkError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitNetworkError> for NetworkError {
    fn from_glib(value: webkit2_sys::WebKitNetworkError) -> Self {
        skip_assert_initialized!();
        match value {
            399 => NetworkError::Failed,
            300 => NetworkError::Transport,
            301 => NetworkError::UnknownProtocol,
            302 => NetworkError::Cancelled,
            303 => NetworkError::FileDoesNotExist,
            value => NetworkError::__Unknown(value),
        }
    }
}

impl ErrorDomain for NetworkError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_network_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            399 => Some(NetworkError::Failed),
            300 => Some(NetworkError::Transport),
            301 => Some(NetworkError::UnknownProtocol),
            302 => Some(NetworkError::Cancelled),
            303 => Some(NetworkError::FileDoesNotExist),
            _ => Some(NetworkError::Failed),
        }
    }
}

impl StaticType for NetworkError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_network_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NetworkError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NetworkError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NetworkError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum NetworkProxyMode {
    Default,
    NoProxy,
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl fmt::Display for NetworkProxyMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "NetworkProxyMode::{}", match *self {
            NetworkProxyMode::Default => "Default",
            NetworkProxyMode::NoProxy => "NoProxy",
            NetworkProxyMode::Custom => "Custom",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for NetworkProxyMode {
    type GlibType = webkit2_sys::WebKitNetworkProxyMode;

    fn to_glib(&self) -> webkit2_sys::WebKitNetworkProxyMode {
        match *self {
            NetworkProxyMode::Default => webkit2_sys::WEBKIT_NETWORK_PROXY_MODE_DEFAULT,
            NetworkProxyMode::NoProxy => webkit2_sys::WEBKIT_NETWORK_PROXY_MODE_NO_PROXY,
            NetworkProxyMode::Custom => webkit2_sys::WEBKIT_NETWORK_PROXY_MODE_CUSTOM,
            NetworkProxyMode::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitNetworkProxyMode> for NetworkProxyMode {
    fn from_glib(value: webkit2_sys::WebKitNetworkProxyMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NetworkProxyMode::Default,
            1 => NetworkProxyMode::NoProxy,
            2 => NetworkProxyMode::Custom,
            value => NetworkProxyMode::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl StaticType for NetworkProxyMode {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_network_proxy_mode_get_type()) }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl<'a> FromValueOptional<'a> for NetworkProxyMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl<'a> FromValue<'a> for NetworkProxyMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl SetValue for NetworkProxyMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum PluginError {
    Failed,
    CannotFindPlugin,
    CannotLoadPlugin,
    JavaUnavailable,
    ConnectionCancelled,
    WillHandleLoad,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PluginError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PluginError::{}", match *self {
            PluginError::Failed => "Failed",
            PluginError::CannotFindPlugin => "CannotFindPlugin",
            PluginError::CannotLoadPlugin => "CannotLoadPlugin",
            PluginError::JavaUnavailable => "JavaUnavailable",
            PluginError::ConnectionCancelled => "ConnectionCancelled",
            PluginError::WillHandleLoad => "WillHandleLoad",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for PluginError {
    type GlibType = webkit2_sys::WebKitPluginError;

    fn to_glib(&self) -> webkit2_sys::WebKitPluginError {
        match *self {
            PluginError::Failed => webkit2_sys::WEBKIT_PLUGIN_ERROR_FAILED,
            PluginError::CannotFindPlugin => webkit2_sys::WEBKIT_PLUGIN_ERROR_CANNOT_FIND_PLUGIN,
            PluginError::CannotLoadPlugin => webkit2_sys::WEBKIT_PLUGIN_ERROR_CANNOT_LOAD_PLUGIN,
            PluginError::JavaUnavailable => webkit2_sys::WEBKIT_PLUGIN_ERROR_JAVA_UNAVAILABLE,
            PluginError::ConnectionCancelled => webkit2_sys::WEBKIT_PLUGIN_ERROR_CONNECTION_CANCELLED,
            PluginError::WillHandleLoad => webkit2_sys::WEBKIT_PLUGIN_ERROR_WILL_HANDLE_LOAD,
            PluginError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitPluginError> for PluginError {
    fn from_glib(value: webkit2_sys::WebKitPluginError) -> Self {
        skip_assert_initialized!();
        match value {
            299 => PluginError::Failed,
            200 => PluginError::CannotFindPlugin,
            201 => PluginError::CannotLoadPlugin,
            202 => PluginError::JavaUnavailable,
            203 => PluginError::ConnectionCancelled,
            204 => PluginError::WillHandleLoad,
            value => PluginError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PluginError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_plugin_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            299 => Some(PluginError::Failed),
            200 => Some(PluginError::CannotFindPlugin),
            201 => Some(PluginError::CannotLoadPlugin),
            202 => Some(PluginError::JavaUnavailable),
            203 => Some(PluginError::ConnectionCancelled),
            204 => Some(PluginError::WillHandleLoad),
            _ => Some(PluginError::Failed),
        }
    }
}

impl StaticType for PluginError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_plugin_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PluginError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PluginError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PluginError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum PolicyDecisionType {
    NavigationAction,
    NewWindowAction,
    Response,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PolicyDecisionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PolicyDecisionType::{}", match *self {
            PolicyDecisionType::NavigationAction => "NavigationAction",
            PolicyDecisionType::NewWindowAction => "NewWindowAction",
            PolicyDecisionType::Response => "Response",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for PolicyDecisionType {
    type GlibType = webkit2_sys::WebKitPolicyDecisionType;

    fn to_glib(&self) -> webkit2_sys::WebKitPolicyDecisionType {
        match *self {
            PolicyDecisionType::NavigationAction => webkit2_sys::WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION,
            PolicyDecisionType::NewWindowAction => webkit2_sys::WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION,
            PolicyDecisionType::Response => webkit2_sys::WEBKIT_POLICY_DECISION_TYPE_RESPONSE,
            PolicyDecisionType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitPolicyDecisionType> for PolicyDecisionType {
    fn from_glib(value: webkit2_sys::WebKitPolicyDecisionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PolicyDecisionType::NavigationAction,
            1 => PolicyDecisionType::NewWindowAction,
            2 => PolicyDecisionType::Response,
            value => PolicyDecisionType::__Unknown(value),
        }
    }
}

impl StaticType for PolicyDecisionType {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_policy_decision_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PolicyDecisionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PolicyDecisionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PolicyDecisionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum PolicyError {
    Failed,
    CannotShowMimeType,
    CannotShowUri,
    FrameLoadInterruptedByPolicyChange,
    CannotUseRestrictedPort,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PolicyError::{}", match *self {
            PolicyError::Failed => "Failed",
            PolicyError::CannotShowMimeType => "CannotShowMimeType",
            PolicyError::CannotShowUri => "CannotShowUri",
            PolicyError::FrameLoadInterruptedByPolicyChange => "FrameLoadInterruptedByPolicyChange",
            PolicyError::CannotUseRestrictedPort => "CannotUseRestrictedPort",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for PolicyError {
    type GlibType = webkit2_sys::WebKitPolicyError;

    fn to_glib(&self) -> webkit2_sys::WebKitPolicyError {
        match *self {
            PolicyError::Failed => webkit2_sys::WEBKIT_POLICY_ERROR_FAILED,
            PolicyError::CannotShowMimeType => webkit2_sys::WEBKIT_POLICY_ERROR_CANNOT_SHOW_MIME_TYPE,
            PolicyError::CannotShowUri => webkit2_sys::WEBKIT_POLICY_ERROR_CANNOT_SHOW_URI,
            PolicyError::FrameLoadInterruptedByPolicyChange => webkit2_sys::WEBKIT_POLICY_ERROR_FRAME_LOAD_INTERRUPTED_BY_POLICY_CHANGE,
            PolicyError::CannotUseRestrictedPort => webkit2_sys::WEBKIT_POLICY_ERROR_CANNOT_USE_RESTRICTED_PORT,
            PolicyError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitPolicyError> for PolicyError {
    fn from_glib(value: webkit2_sys::WebKitPolicyError) -> Self {
        skip_assert_initialized!();
        match value {
            199 => PolicyError::Failed,
            100 => PolicyError::CannotShowMimeType,
            101 => PolicyError::CannotShowUri,
            102 => PolicyError::FrameLoadInterruptedByPolicyChange,
            103 => PolicyError::CannotUseRestrictedPort,
            value => PolicyError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PolicyError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_policy_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            199 => Some(PolicyError::Failed),
            100 => Some(PolicyError::CannotShowMimeType),
            101 => Some(PolicyError::CannotShowUri),
            102 => Some(PolicyError::FrameLoadInterruptedByPolicyChange),
            103 => Some(PolicyError::CannotUseRestrictedPort),
            _ => Some(PolicyError::Failed),
        }
    }
}

impl StaticType for PolicyError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_policy_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PolicyError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PolicyError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PolicyError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum PrintError {
    General,
    PrinterNotFound,
    InvalidPageRange,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PrintError::{}", match *self {
            PrintError::General => "General",
            PrintError::PrinterNotFound => "PrinterNotFound",
            PrintError::InvalidPageRange => "InvalidPageRange",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for PrintError {
    type GlibType = webkit2_sys::WebKitPrintError;

    fn to_glib(&self) -> webkit2_sys::WebKitPrintError {
        match *self {
            PrintError::General => webkit2_sys::WEBKIT_PRINT_ERROR_GENERAL,
            PrintError::PrinterNotFound => webkit2_sys::WEBKIT_PRINT_ERROR_PRINTER_NOT_FOUND,
            PrintError::InvalidPageRange => webkit2_sys::WEBKIT_PRINT_ERROR_INVALID_PAGE_RANGE,
            PrintError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitPrintError> for PrintError {
    fn from_glib(value: webkit2_sys::WebKitPrintError) -> Self {
        skip_assert_initialized!();
        match value {
            599 => PrintError::General,
            500 => PrintError::PrinterNotFound,
            501 => PrintError::InvalidPageRange,
            value => PrintError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PrintError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_print_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            599 => Some(PrintError::General),
            500 => Some(PrintError::PrinterNotFound),
            501 => Some(PrintError::InvalidPageRange),
            value => Some(PrintError::__Unknown(value)),
        }
    }
}

impl StaticType for PrintError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_print_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum PrintOperationResponse {
    Print,
    Cancel,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintOperationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PrintOperationResponse::{}", match *self {
            PrintOperationResponse::Print => "Print",
            PrintOperationResponse::Cancel => "Cancel",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for PrintOperationResponse {
    type GlibType = webkit2_sys::WebKitPrintOperationResponse;

    fn to_glib(&self) -> webkit2_sys::WebKitPrintOperationResponse {
        match *self {
            PrintOperationResponse::Print => webkit2_sys::WEBKIT_PRINT_OPERATION_RESPONSE_PRINT,
            PrintOperationResponse::Cancel => webkit2_sys::WEBKIT_PRINT_OPERATION_RESPONSE_CANCEL,
            PrintOperationResponse::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitPrintOperationResponse> for PrintOperationResponse {
    fn from_glib(value: webkit2_sys::WebKitPrintOperationResponse) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintOperationResponse::Print,
            1 => PrintOperationResponse::Cancel,
            value => PrintOperationResponse::__Unknown(value),
        }
    }
}

impl StaticType for PrintOperationResponse {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_print_operation_response_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintOperationResponse {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintOperationResponse {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintOperationResponse {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum ProcessModel {
    SharedSecondaryProcess,
    MultipleSecondaryProcesses,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
impl fmt::Display for ProcessModel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ProcessModel::{}", match *self {
            ProcessModel::SharedSecondaryProcess => "SharedSecondaryProcess",
            ProcessModel::MultipleSecondaryProcesses => "MultipleSecondaryProcesses",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for ProcessModel {
    type GlibType = webkit2_sys::WebKitProcessModel;

    fn to_glib(&self) -> webkit2_sys::WebKitProcessModel {
        match *self {
            ProcessModel::SharedSecondaryProcess => webkit2_sys::WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS,
            ProcessModel::MultipleSecondaryProcesses => webkit2_sys::WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES,
            ProcessModel::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitProcessModel> for ProcessModel {
    fn from_glib(value: webkit2_sys::WebKitProcessModel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ProcessModel::SharedSecondaryProcess,
            1 => ProcessModel::MultipleSecondaryProcesses,
            value => ProcessModel::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
impl StaticType for ProcessModel {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_process_model_get_type()) }
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
impl<'a> FromValueOptional<'a> for ProcessModel {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
impl<'a> FromValue<'a> for ProcessModel {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
impl SetValue for ProcessModel {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum SaveMode {
    Mhtml,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SaveMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SaveMode::{}", match *self {
            SaveMode::Mhtml => "Mhtml",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for SaveMode {
    type GlibType = webkit2_sys::WebKitSaveMode;

    fn to_glib(&self) -> webkit2_sys::WebKitSaveMode {
        match *self {
            SaveMode::Mhtml => webkit2_sys::WEBKIT_SAVE_MODE_MHTML,
            SaveMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitSaveMode> for SaveMode {
    fn from_glib(value: webkit2_sys::WebKitSaveMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SaveMode::Mhtml,
            value => SaveMode::__Unknown(value),
        }
    }
}

impl StaticType for SaveMode {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_save_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SaveMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SaveMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SaveMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum ScriptDialogType {
    Alert,
    Confirm,
    Prompt,
    BeforeUnloadConfirm,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScriptDialogType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ScriptDialogType::{}", match *self {
            ScriptDialogType::Alert => "Alert",
            ScriptDialogType::Confirm => "Confirm",
            ScriptDialogType::Prompt => "Prompt",
            ScriptDialogType::BeforeUnloadConfirm => "BeforeUnloadConfirm",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for ScriptDialogType {
    type GlibType = webkit2_sys::WebKitScriptDialogType;

    fn to_glib(&self) -> webkit2_sys::WebKitScriptDialogType {
        match *self {
            ScriptDialogType::Alert => webkit2_sys::WEBKIT_SCRIPT_DIALOG_ALERT,
            ScriptDialogType::Confirm => webkit2_sys::WEBKIT_SCRIPT_DIALOG_CONFIRM,
            ScriptDialogType::Prompt => webkit2_sys::WEBKIT_SCRIPT_DIALOG_PROMPT,
            ScriptDialogType::BeforeUnloadConfirm => webkit2_sys::WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM,
            ScriptDialogType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitScriptDialogType> for ScriptDialogType {
    fn from_glib(value: webkit2_sys::WebKitScriptDialogType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScriptDialogType::Alert,
            1 => ScriptDialogType::Confirm,
            2 => ScriptDialogType::Prompt,
            3 => ScriptDialogType::BeforeUnloadConfirm,
            value => ScriptDialogType::__Unknown(value),
        }
    }
}

impl StaticType for ScriptDialogType {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_script_dialog_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScriptDialogType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScriptDialogType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScriptDialogType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum SnapshotError {
    Create,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SnapshotError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SnapshotError::{}", match *self {
            SnapshotError::Create => "Create",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for SnapshotError {
    type GlibType = webkit2_sys::WebKitSnapshotError;

    fn to_glib(&self) -> webkit2_sys::WebKitSnapshotError {
        match *self {
            SnapshotError::Create => webkit2_sys::WEBKIT_SNAPSHOT_ERROR_FAILED_TO_CREATE,
            SnapshotError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitSnapshotError> for SnapshotError {
    fn from_glib(value: webkit2_sys::WebKitSnapshotError) -> Self {
        skip_assert_initialized!();
        match value {
            799 => SnapshotError::Create,
            value => SnapshotError::__Unknown(value),
        }
    }
}

impl ErrorDomain for SnapshotError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_snapshot_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            799 => Some(SnapshotError::Create),
            value => Some(SnapshotError::__Unknown(value)),
        }
    }
}

impl StaticType for SnapshotError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_snapshot_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SnapshotError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SnapshotError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SnapshotError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum SnapshotRegion {
    Visible,
    FullDocument,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SnapshotRegion {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SnapshotRegion::{}", match *self {
            SnapshotRegion::Visible => "Visible",
            SnapshotRegion::FullDocument => "FullDocument",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for SnapshotRegion {
    type GlibType = webkit2_sys::WebKitSnapshotRegion;

    fn to_glib(&self) -> webkit2_sys::WebKitSnapshotRegion {
        match *self {
            SnapshotRegion::Visible => webkit2_sys::WEBKIT_SNAPSHOT_REGION_VISIBLE,
            SnapshotRegion::FullDocument => webkit2_sys::WEBKIT_SNAPSHOT_REGION_FULL_DOCUMENT,
            SnapshotRegion::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitSnapshotRegion> for SnapshotRegion {
    fn from_glib(value: webkit2_sys::WebKitSnapshotRegion) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SnapshotRegion::Visible,
            1 => SnapshotRegion::FullDocument,
            value => SnapshotRegion::__Unknown(value),
        }
    }
}

impl StaticType for SnapshotRegion {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_snapshot_region_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SnapshotRegion {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SnapshotRegion {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SnapshotRegion {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum TLSErrorsPolicy {
    Ignore,
    Fail,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TLSErrorsPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "TLSErrorsPolicy::{}", match *self {
            TLSErrorsPolicy::Ignore => "Ignore",
            TLSErrorsPolicy::Fail => "Fail",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for TLSErrorsPolicy {
    type GlibType = webkit2_sys::WebKitTLSErrorsPolicy;

    fn to_glib(&self) -> webkit2_sys::WebKitTLSErrorsPolicy {
        match *self {
            TLSErrorsPolicy::Ignore => webkit2_sys::WEBKIT_TLS_ERRORS_POLICY_IGNORE,
            TLSErrorsPolicy::Fail => webkit2_sys::WEBKIT_TLS_ERRORS_POLICY_FAIL,
            TLSErrorsPolicy::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitTLSErrorsPolicy> for TLSErrorsPolicy {
    fn from_glib(value: webkit2_sys::WebKitTLSErrorsPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TLSErrorsPolicy::Ignore,
            1 => TLSErrorsPolicy::Fail,
            value => TLSErrorsPolicy::__Unknown(value),
        }
    }
}

impl StaticType for TLSErrorsPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_tls_errors_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TLSErrorsPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TLSErrorsPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TLSErrorsPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum UserContentFilterError {
    InvalidSource,
    NotFound,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
impl fmt::Display for UserContentFilterError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "UserContentFilterError::{}", match *self {
            UserContentFilterError::InvalidSource => "InvalidSource",
            UserContentFilterError::NotFound => "NotFound",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for UserContentFilterError {
    type GlibType = webkit2_sys::WebKitUserContentFilterError;

    fn to_glib(&self) -> webkit2_sys::WebKitUserContentFilterError {
        match *self {
            UserContentFilterError::InvalidSource => webkit2_sys::WEBKIT_USER_CONTENT_FILTER_ERROR_INVALID_SOURCE,
            UserContentFilterError::NotFound => webkit2_sys::WEBKIT_USER_CONTENT_FILTER_ERROR_NOT_FOUND,
            UserContentFilterError::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitUserContentFilterError> for UserContentFilterError {
    fn from_glib(value: webkit2_sys::WebKitUserContentFilterError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserContentFilterError::InvalidSource,
            1 => UserContentFilterError::NotFound,
            value => UserContentFilterError::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
impl ErrorDomain for UserContentFilterError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_user_content_filter_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(UserContentFilterError::InvalidSource),
            1 => Some(UserContentFilterError::NotFound),
            value => Some(UserContentFilterError::__Unknown(value)),
        }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
impl StaticType for UserContentFilterError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_user_content_filter_error_get_type()) }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
impl<'a> FromValueOptional<'a> for UserContentFilterError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
impl<'a> FromValue<'a> for UserContentFilterError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
impl SetValue for UserContentFilterError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum UserContentInjectedFrames {
    AllFrames,
    TopFrame,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl fmt::Display for UserContentInjectedFrames {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "UserContentInjectedFrames::{}", match *self {
            UserContentInjectedFrames::AllFrames => "AllFrames",
            UserContentInjectedFrames::TopFrame => "TopFrame",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for UserContentInjectedFrames {
    type GlibType = webkit2_sys::WebKitUserContentInjectedFrames;

    fn to_glib(&self) -> webkit2_sys::WebKitUserContentInjectedFrames {
        match *self {
            UserContentInjectedFrames::AllFrames => webkit2_sys::WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES,
            UserContentInjectedFrames::TopFrame => webkit2_sys::WEBKIT_USER_CONTENT_INJECT_TOP_FRAME,
            UserContentInjectedFrames::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitUserContentInjectedFrames> for UserContentInjectedFrames {
    fn from_glib(value: webkit2_sys::WebKitUserContentInjectedFrames) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserContentInjectedFrames::AllFrames,
            1 => UserContentInjectedFrames::TopFrame,
            value => UserContentInjectedFrames::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl StaticType for UserContentInjectedFrames {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_user_content_injected_frames_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for UserContentInjectedFrames {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValue<'a> for UserContentInjectedFrames {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl SetValue for UserContentInjectedFrames {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum UserMessageError {
    Message,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl fmt::Display for UserMessageError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "UserMessageError::{}", match *self {
            UserMessageError::Message => "Message",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for UserMessageError {
    type GlibType = webkit2_sys::WebKitUserMessageError;

    fn to_glib(&self) -> webkit2_sys::WebKitUserMessageError {
        match *self {
            UserMessageError::Message => webkit2_sys::WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE,
            UserMessageError::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitUserMessageError> for UserMessageError {
    fn from_glib(value: webkit2_sys::WebKitUserMessageError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserMessageError::Message,
            value => UserMessageError::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl ErrorDomain for UserMessageError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(webkit2_sys::webkit_user_message_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(UserMessageError::Message),
            value => Some(UserMessageError::__Unknown(value)),
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl StaticType for UserMessageError {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_user_message_error_get_type()) }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl<'a> FromValueOptional<'a> for UserMessageError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl<'a> FromValue<'a> for UserMessageError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl SetValue for UserMessageError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum UserScriptInjectionTime {
    Start,
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl fmt::Display for UserScriptInjectionTime {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "UserScriptInjectionTime::{}", match *self {
            UserScriptInjectionTime::Start => "Start",
            UserScriptInjectionTime::End => "End",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for UserScriptInjectionTime {
    type GlibType = webkit2_sys::WebKitUserScriptInjectionTime;

    fn to_glib(&self) -> webkit2_sys::WebKitUserScriptInjectionTime {
        match *self {
            UserScriptInjectionTime::Start => webkit2_sys::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START,
            UserScriptInjectionTime::End => webkit2_sys::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END,
            UserScriptInjectionTime::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitUserScriptInjectionTime> for UserScriptInjectionTime {
    fn from_glib(value: webkit2_sys::WebKitUserScriptInjectionTime) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserScriptInjectionTime::Start,
            1 => UserScriptInjectionTime::End,
            value => UserScriptInjectionTime::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl StaticType for UserScriptInjectionTime {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_user_script_injection_time_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for UserScriptInjectionTime {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValue<'a> for UserScriptInjectionTime {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl SetValue for UserScriptInjectionTime {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum UserStyleLevel {
    User,
    Author,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl fmt::Display for UserStyleLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "UserStyleLevel::{}", match *self {
            UserStyleLevel::User => "User",
            UserStyleLevel::Author => "Author",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for UserStyleLevel {
    type GlibType = webkit2_sys::WebKitUserStyleLevel;

    fn to_glib(&self) -> webkit2_sys::WebKitUserStyleLevel {
        match *self {
            UserStyleLevel::User => webkit2_sys::WEBKIT_USER_STYLE_LEVEL_USER,
            UserStyleLevel::Author => webkit2_sys::WEBKIT_USER_STYLE_LEVEL_AUTHOR,
            UserStyleLevel::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitUserStyleLevel> for UserStyleLevel {
    fn from_glib(value: webkit2_sys::WebKitUserStyleLevel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserStyleLevel::User,
            1 => UserStyleLevel::Author,
            value => UserStyleLevel::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl StaticType for UserStyleLevel {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_user_style_level_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for UserStyleLevel {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValue<'a> for UserStyleLevel {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl SetValue for UserStyleLevel {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum WebProcessTerminationReason {
    Crashed,
    ExceededMemoryLimit,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
impl fmt::Display for WebProcessTerminationReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "WebProcessTerminationReason::{}", match *self {
            WebProcessTerminationReason::Crashed => "Crashed",
            WebProcessTerminationReason::ExceededMemoryLimit => "ExceededMemoryLimit",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebProcessTerminationReason {
    type GlibType = webkit2_sys::WebKitWebProcessTerminationReason;

    fn to_glib(&self) -> webkit2_sys::WebKitWebProcessTerminationReason {
        match *self {
            WebProcessTerminationReason::Crashed => webkit2_sys::WEBKIT_WEB_PROCESS_CRASHED,
            WebProcessTerminationReason::ExceededMemoryLimit => webkit2_sys::WEBKIT_WEB_PROCESS_EXCEEDED_MEMORY_LIMIT,
            WebProcessTerminationReason::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitWebProcessTerminationReason> for WebProcessTerminationReason {
    fn from_glib(value: webkit2_sys::WebKitWebProcessTerminationReason) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebProcessTerminationReason::Crashed,
            1 => WebProcessTerminationReason::ExceededMemoryLimit,
            value => WebProcessTerminationReason::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
impl StaticType for WebProcessTerminationReason {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_web_process_termination_reason_get_type()) }
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebProcessTerminationReason {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
impl<'a> FromValue<'a> for WebProcessTerminationReason {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
impl SetValue for WebProcessTerminationReason {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAutoplayPolicy")]
pub enum AutoplayPolicy {
    #[doc(alias = "WEBKIT_AUTOPLAY_ALLOW")]
    Allow,
    #[doc(alias = "WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND")]
    AllowWithoutSound,
    #[doc(alias = "WEBKIT_AUTOPLAY_DENY")]
    Deny,
    #[doc(hidden)]
    __Unknown(i32),
}


#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl fmt::Display for AutoplayPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AutoplayPolicy::{}",
            match *self {
                Self::Allow => "Allow",
                Self::AllowWithoutSound => "AllowWithoutSound",
                Self::Deny => "Deny",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl ToGlib for AutoplayPolicy {
    type GlibType = webkit2_sys::WebKitAutoplayPolicy;

    fn to_glib(&self) -> webkit2_sys::WebKitAutoplayPolicy {
        match *self {
            Self::Allow => webkit2_sys::WEBKIT_AUTOPLAY_ALLOW,
            Self::AllowWithoutSound => webkit2_sys::WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND,
            Self::Deny => webkit2_sys::WEBKIT_AUTOPLAY_DENY,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl FromGlib<webkit2_sys::WebKitAutoplayPolicy> for AutoplayPolicy {
    fn from_glib(value: webkit2_sys::WebKitAutoplayPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            webkit2_sys::WEBKIT_AUTOPLAY_ALLOW => Self::Allow,
            webkit2_sys::WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND => Self::AllowWithoutSound,
            webkit2_sys::WEBKIT_AUTOPLAY_DENY => Self::Deny,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl StaticType for AutoplayPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(webkit2_sys::webkit_autoplay_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AutoplayPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl <'a> FromValue<'a> for AutoplayPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
impl SetValue for AutoplayPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        unsafe {
            gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib());
        }
    }
}
